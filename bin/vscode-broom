#!/usr/bin/env bash
# SPDX-License-Identifier: GPL-3.0-or-later
set -uo pipefail
IFS=$'\n\t'

TARGET="all"
ACTION="analyze"
TARGET_SET=false
ACTION_SET=false
EXECUTE=false
PRUNE_UNINSTALLED=false
INCLUDE_WS_STORAGE=false
INCLUDE_GLOBAL_STORAGE=false
EXT_FLAG_USED=false
CACHE_FLAG_USED=false
HOST_FLAG_USED=false
VERBOSE=false
QUIET=false

EXT_DIRS=()
CONFIG_DIRS=()
HOST_DIRS=()
TARGET_PATH_FOUND=false
DETECTED_ROOTS=()
DETECTED_VARIANTS=()

STALE_EXT_COUNT=0
STALE_EXT_BYTES=0
STALE_HOST_COUNT=0
STALE_HOST_BYTES=0
EXT_USED_BYTES=0
CACHE_USED_BYTES=0
HOST_USED_BYTES=0
CACHE_RECLAIM_BYTES=0
EXT_EXISTING_COUNT=0
CACHE_EXISTING_COUNT=0
HOST_EXISTING_COUNT=0
PRINT_GAP=false

DEFAULT_ROOTS=(
  "$HOME/.vscode"
  "$HOME/.vscode-insiders"
  "$HOME/.vscode-oss"
  "$HOME/.vscode-server"
  "$HOME/.vscode-server-insiders"
)

BANNER_VSCODE_LINES=(
  '██    ██  ██████   ██████   ██████   ██████   ███████'
  '██    ██ ██       ██    ██ ██    ██  ██   ██  ██     '
  '██    ██ ███████  ██       ██    ██  ██   ██  █████  '
  ' ██  ██       ██  ██       ██    ██  ██   ██  ██     '
  '  ████    ██████   ██████   ██████   ██████   ███████'
)

BANNER_BROOM_ICON=(
  '       █'
  '      █ '
  '     █  '
  '   ▄███▄'
  '   ▀▀▀▀▀'
)

BANNER_BROOM_TEXT=(
  '██████   ██████   ██████   ██████   ███    ███'
  '██   ██  ██   ██ ██    ██ ██    ██  ████  ████'
  '██████   ██████  ██    ██ ██    ██  ██ ████ ██'
  '██   ██  ██   ██ ██    ██ ██    ██  ██  ██  ██'
  '██████   ██   ██  ██████   ██████   ██      ██'
)

variant_label() {
  local root="${1%/}"
  case "$root" in
    */cli)
      printf 'VS Code Server'
      ;;
    */.vscode-server-insiders*)
      printf 'VS Code Server Insiders'
      ;;
    */.vscode-server*)
      printf 'VS Code Server'
      ;;
    */.vscode-insiders*)
      printf 'VS Code Insiders'
      ;;
    */.vscode-oss*)
      printf 'VSCodium/OSS'
      ;;
    */.vscode*)
      printf 'VS Code'
      ;;
    *)
      printf '%s' "$root"
      ;;
  esac
}

variant_label_from_config_base() {
  local base=$1
  case "$base" in
    */com.visualstudio.code/config/Code)
      printf 'VS Code'
      ;;
    */Code)
      printf 'VS Code'
      ;;
    */Code\ -\ Insiders)
      printf 'VS Code Insiders'
      ;;
    */VSCodium)
      printf 'VSCodium/OSS'
      ;;
    *)
      printf ''
      ;;
  esac
}

desktop_cli_candidates_for_root() {
  local root=$1
  case "$root" in
    "$HOME/.vscode-insiders")
      printf '%s\n' "code-insiders"
      ;;
    "$HOME/.vscode-oss")
      printf '%s\n' "codium"
      printf '%s\n' "code-oss"
      ;;
    *)
      printf '%s\n' "code"
      ;;
  esac
}

desktop_cli_required_for_root() {
  local root=$1
  case "$root" in
    "$HOME/.vscode" | "$HOME/.vscode-insiders" | "$HOME/.vscode-oss")
      return 1
      ;;
    *)
      return 0
      ;;
  esac
}

DEFAULT_CONFIG_BASES=(
  "$HOME/.config/Code"
  "$HOME/.config/Code - Insiders"
  "$HOME/.config/VSCodium"
  "$HOME/.var/app/com.visualstudio.code/config/Code"
)

DEFAULT_EXT_DIRS=()
DEFAULT_CONFIG_DIRS=()
DEFAULT_HOST_DIRS=()

build_default_paths() {
  # Collect roots from explicit candidates; no globs
  local -a roots=()
  declare -A seen=()

  local match
  for match in "${DEFAULT_ROOTS[@]}"; do
    [[ -d "$match" ]] || continue
    if [[ -z ${seen[$match]:-} ]]; then
      roots+=("$match")
      seen[$match]=1
      DETECTED_ROOTS+=("$match")
      DETECTED_VARIANTS+=("$(variant_label "$match")")
    fi
  done

  # If nothing found, keep the list empty rather than inventing paths

  if [[ ${#DEFAULT_EXT_DIRS[@]} -eq 0 ]]; then
    local root
    for root in "${roots[@]}"; do
      case "$root" in
        */cli*) ;; # cli roots are for host/server assets only
        *)
          DEFAULT_EXT_DIRS+=("$root/extensions")
          ;;
      esac
    done
  fi

  if [[ ${#DEFAULT_CONFIG_DIRS[@]} -eq 0 ]]; then
    local base
    for base in "${DEFAULT_CONFIG_BASES[@]}"; do
      [[ -d "$base" ]] || continue
      DEFAULT_CONFIG_DIRS+=("$base")
      local label
      label=$(variant_label_from_config_base "$base")
      [[ -n "$label" ]] && DETECTED_VARIANTS+=("$label")
    done

    local root
    for root in "${roots[@]}"; do
      case "$root" in
        */cli*) ;; # no user data under cli roots
        *.vscode-server*)
          [[ -d "$root/data" ]] && DEFAULT_CONFIG_DIRS+=("$root/data")
          ;;
      esac
    done
  fi

  if [[ ${#DEFAULT_HOST_DIRS[@]} -eq 0 ]]; then
    local root
    for root in "${roots[@]}"; do
      case "$root" in
        *.vscode-server*)
          DEFAULT_HOST_DIRS+=("$root")
          [[ -d "$root/bin" ]] && DEFAULT_HOST_DIRS+=("$root/bin")
          [[ -d "$root/cli/servers" ]] && DEFAULT_HOST_DIRS+=("$root/cli/servers")
          ;;
      esac
    done
  fi
}

build_default_paths

log() {
  printf '%s\n' "$*"
}

join_by() {
  local delim=$1
  shift
  local first=1
  local part
  for part in "$@"; do
    if ((first)); then
      printf '%s' "$part"
      first=0
    else
      printf '%s%s' "$delim" "$part"
    fi
  done
}

dedupe_ext_dirs() {
  declare -A seen=()
  local -a unique=()
  local dir
  for dir in "${EXT_DIRS[@]}"; do
    if [[ -z ${seen[$dir]:-} ]]; then
      unique+=("$dir")
      seen[$dir]=1
    fi
  done
  EXT_DIRS=("${unique[@]}")
}

dedupe_config_dirs() {
  declare -A seen=()
  local -a unique=()
  local dir
  for dir in "${CONFIG_DIRS[@]}"; do
    if [[ -z ${seen[$dir]:-} ]]; then
      unique+=("$dir")
      seen[$dir]=1
    fi
  done
  CONFIG_DIRS=("${unique[@]}")
}

dedupe_host_dirs() {
  declare -A seen=()
  local -a unique=()
  local dir
  for dir in "${HOST_DIRS[@]}"; do
    if [[ -z ${seen[$dir]:-} ]]; then
      unique+=("$dir")
      seen[$dir]=1
    fi
  done
  HOST_DIRS=("${unique[@]}")
}

print_missing() {
  local always=false
  if [[ "${1:-}" == "--always" ]]; then
    always=true
    shift
  fi

  local label=$1
  shift
  local -a items=("$@")
  ((${#items[@]} == 0)) && return

  if ! "$VERBOSE" && ! "$always"; then
    return
  fi

  if "$PRINT_GAP"; then
    echo
  fi

  local limit=10
  local count=${#items[@]}
  log "Missing ${label}:""${count:+" (total $count)"}"
  local i=0
  while ((i < count && i < limit)); do
    printf '  - %s\n' "${items[$i]}"
    ((i += 1))
  done
  if ((count > limit)); then
    printf '    ... (+%d more)\n' "$((count - limit))"
  fi

  PRINT_GAP=true
}

human_path() {
  local p=$1
  case "$p" in
    "$HOME"/*)
      # shellcheck disable=SC2088
      printf '~/%s' "${p#"$HOME/"}"
      ;;
    *)
      printf '%s' "$p"
      ;;
  esac
}

warn() {
  printf 'warning: %s\n' "$*" >&2
}

err() {
  printf 'error: %s\n' "$*" >&2
  exit 1
}

is_unsafe_root_path() {
  local path=$1

  local home_real
  local home_parent
  if ! home_real=$(cd "$HOME" 2> /dev/null && pwd -P); then
    home_real=$HOME
  fi
  if ! home_parent=$(cd "$HOME/.." 2> /dev/null && pwd -P); then
    home_parent=""
  fi

  case "$path" in
    / | "$home_real" | "$home_real/" | "$home_real/.")
      return 0
      ;;
  esac

  if [[ -n "$home_parent" ]]; then
    case "$path" in
      "$home_parent" | "$home_parent/")
        return 0
        ;;
    esac
  fi

  return 1
}

validate_user_dir() {
  local flag=$1
  local path=$2
  if [[ ! -d "$path" ]]; then
    err "$flag requires an existing directory: $path"
  fi

  local resolved
  if ! resolved=$(cd "$path" 2> /dev/null && pwd -P); then
    err "$flag requires an existing directory: $path"
  fi

  if is_unsafe_root_path "$resolved"; then
    err "$flag refuses to use unsafe path: $path"
  fi
}

is_under_root() {
  local path=$1
  local root=$2
  [[ "$path" == "$root" || "$path" == "$root/"* ]]
}

validate_removal_paths() {
  local -a bad=()
  local path root
  for path in "${PLAN_REMOVALS[@]}"; do
    local ok=false
    for root in "${EXT_DIRS[@]}" "${CONFIG_DIRS[@]}" "${HOST_DIRS[@]}"; do
      if [[ -n "$root" ]] && is_under_root "$path" "$root"; then
        ok=true
        break
      fi
    done
    if ! "$ok"; then
      bad+=("$(human_path "$path")")
    fi
  done

  if ((${#bad[@]})); then
    err "Refusing to delete unexpected paths: $(join_by ', ' "${bad[@]}")"
  fi
}

dir_size_bytes() {
  local path=$1
  if [[ -e "$path" ]]; then
    local bytes
    if bytes=$(du -sb "$path" 2> /dev/null | awk '{print $1}'); then
      if [[ -n "$bytes" ]]; then
        printf '%s' "$bytes"
        return 0
      fi
    fi
    "$VERBOSE" && warn "du failed for $(human_path "$path")"
    printf '0'
  else
    printf '0'
  fi
}

format_bytes() {
  local bytes=$1
  numfmt --to=iec --suffix=B "$bytes" 2> /dev/null || echo "${bytes}B"
}

utf8_locale() {
  local locale=${LC_ALL:-${LC_CTYPE:-${LANG:-}}}
  case "${locale,,}" in
    *utf-8* | *utf8*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

color_enabled() {
  [[ -t 1 ]] || return 1
  [[ -z ${NO_COLOR+x} ]] || return 1
  [[ ${TERM:-} != "dumb" ]] || return 1

  if ! command_exists tput; then
    return 1
  fi

  local colors
  colors=$(tput colors 2> /dev/null || true)
  [[ "$colors" =~ ^[0-9]+$ ]] || return 1
  [[ "$colors" -ge 8 ]]
}

print_banner_plain() {
  local line
  for line in "${BANNER_VSCODE_LINES[@]}"; do
    printf '%s\n' "$line"
  done
  printf '\n'

  local i
  for i in "${!BANNER_BROOM_TEXT[@]}"; do
    printf '%s   %s\n' "${BANNER_BROOM_ICON[$i]}" "${BANNER_BROOM_TEXT[$i]}"
  done
  printf '\n'

  local footer_suffix=$' \xF0\x9F\xA7\xB9'
  printf '%s%s\n' "VSCODE BROOM" "$footer_suffix"
  printf '\n'
}

truecolor_enabled() {
  case "${COLORTERM:-}" in
    truecolor | 24bit)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

ansi_palette_level() {
  local colors
  colors=$(tput colors 2> /dev/null || true)
  if [[ ! "$colors" =~ ^[0-9]+$ ]]; then
    printf '8'
    return 0
  fi

  if ((colors >= 256)); then
    printf '256'
  elif ((colors >= 16)); then
    printf '16'
  else
    printf '8'
  fi
}

print_gradient_string_ansi() {
  local line=$1
  shift
  local -a palette=("$@")
  local count=${#palette[@]}
  local len=${#line}
  local i char idx color

  if ((count == 0)); then
    printf '%s' "$line"
    return 0
  fi

  if ((len < 2)); then
    printf '\033[38;5;%dm%s' "${palette[0]}" "$line"
    return 0
  fi

  for ((i = 0; i < len; i++)); do
    char="${line:$i:1}"
    if [[ "$char" == " " ]]; then
      printf " "
      continue
    fi
    idx=$((i * (count - 1) / (len - 1)))
    color=${palette[$idx]}
    printf '\033[38;5;%dm%s' "$color" "$char"
  done
}

print_gradient_line_ansi() {
  local line=$1
  shift
  print_gradient_string_ansi "$line" "$@"
  printf '\033[0m\n'
}

print_banner_ansi() {
  local reset=$'\033[0m'
  local palette_level
  palette_level=$(ansi_palette_level)
  local -a vscode_palette=()
  local -a broom_palette=()
  local -a footer_palette=()
  local -a handle_palette=()
  local -a bristle_palette=()
  local line i

  case "$palette_level" in
    256)
      vscode_palette=(33 39 45 51 87)
      broom_palette=(129 135 141 177 205)
      footer_palette=(39 45 51 87 123)
      handle_palette=(94 130 136)
      bristle_palette=(220 214 208)
      ;;
    16)
      vscode_palette=(12 14 7)
      broom_palette=(13 5 7)
      footer_palette=(14 6 7)
      handle_palette=(3 11)
      bristle_palette=(11 7)
      ;;
    *)
      vscode_palette=(4 6)
      broom_palette=(5 7)
      footer_palette=(6 7)
      handle_palette=(3)
      bristle_palette=(3 7)
      ;;
  esac

  # VSCODE: Gradient
  for line in "${BANNER_VSCODE_LINES[@]}"; do
    print_gradient_line_ansi "$line" "${vscode_palette[@]}"
  done
  printf '\n'

  # BROOM: Icon + Text
  for i in "${!BANNER_BROOM_TEXT[@]}"; do
    # Icon
    local icon="${BANNER_BROOM_ICON[$i]}"
    if [[ $i -lt 3 ]]; then
      print_gradient_string_ansi "$icon" "${handle_palette[@]}"
    else
      print_gradient_string_ansi "$icon" "${bristle_palette[@]}"
    fi
    printf '%s   ' "$reset"

    # Text
    print_gradient_string_ansi "${BANNER_BROOM_TEXT[$i]}" "${broom_palette[@]}"
    printf '%s\n' "$reset"
  done
  printf '\n'

  local footer_suffix=$' \xF0\x9F\xA7\xB9'
  local footer_color=${footer_palette[$((${#footer_palette[@]} - 1))]}
  print_gradient_string_ansi "VSCODE BROOM" "${footer_palette[@]}"
  printf '\033[38;5;%dm%s%s\n\n' "$footer_color" "$footer_suffix" "$reset"
}

print_gradient_string_truecolor() {
  local text=$1
  local start_r=$2 start_g=$3 start_b=$4
  local end_r=$5 end_g=$6 end_b=$7

  local len=${#text}
  local denom=$((len - 1))
  ((denom > 0)) || denom=1
  local i char r g b

  for ((i = 0; i < len; i++)); do
    char="${text:$i:1}"
    if [[ "$char" == " " ]]; then
      printf " "
      continue
    fi
    r=$((start_r + (end_r - start_r) * i / denom))
    g=$((start_g + (end_g - start_g) * i / denom))
    b=$((start_b + (end_b - start_b) * i / denom))
    printf '\033[38;2;%d;%d;%dm%s' "$r" "$g" "$b" "$char"
  done
}

print_banner_truecolor() {
  local reset=$'\033[0m'
  local line i j char

  # VSCODE: Blue -> Cyan
  for line in "${BANNER_VSCODE_LINES[@]}"; do
    print_gradient_string_truecolor "$line" 0 122 204 0 180 216
    printf '%s\n' "$reset"
  done
  printf '\n'

  # BROOM: Icon (Brown/Gold) + Text (Purple -> Pink)
  for i in "${!BANNER_BROOM_TEXT[@]}"; do
    # Icon
    local icon="${BANNER_BROOM_ICON[$i]}"
    local icon_len=${#icon}
    for ((j = 0; j < icon_len; j++)); do
      char="${icon:$j:1}"
      if [[ "$char" == " " ]]; then
        printf " "
        continue
      fi
      if [[ $i -lt 3 ]]; then
        # Handle: Brown
        printf '\033[38;2;139;69;19m%s' "$char"
      else
        # Bristles: Gold
        printf '\033[38;2;255;215;0m%s' "$char"
      fi
    done
    printf '\033[0m   '

    # Text
    print_gradient_string_truecolor "${BANNER_BROOM_TEXT[$i]}" 138 43 226 255 20 147
    printf '%s\n' "$reset"
  done
  printf '\n'

  # Footer Text Gradient
  local footer_suffix=$' \xF0\x9F\xA7\xB9'
  print_gradient_string_truecolor "VSCODE BROOM" 0 122 204 255 20 147
  printf '\033[38;2;255;20;147m%s%s\n\n' "$footer_suffix" "$reset"
}

print_banner_ascii() {
  local line
  for line in "${BANNER_VSCODE_LINES[@]}"; do
    # Replace block characters with ASCII equivalents
    line=${line//█/#}
    printf '%s\n' "$line"
  done
  printf '\n'

  local i
  for i in "${!BANNER_BROOM_TEXT[@]}"; do
    # Icon
    local icon="${BANNER_BROOM_ICON[$i]}"
    icon=${icon//█/#}
    icon=${icon//▄/_}
    icon=${icon//▀/-}
    printf '%s   ' "$icon"

    # Text
    local text="${BANNER_BROOM_TEXT[$i]}"
    text=${text//█/#}
    printf '%s\n' "$text"
  done
  printf '\n'

  printf 'VSCODE BROOM\n\n'
}

print_banner() {
  "$QUIET" && return 0

  if ! utf8_locale; then
    print_banner_ascii
    return 0
  fi

  if color_enabled; then
    if truecolor_enabled; then
      print_banner_truecolor
    else
      print_banner_ansi
    fi
    return 0
  fi

  print_banner_plain
}

usage() {
  print_banner
  printf '%s\n' \
    'Usage:' \
    '  vscode-broom [target] [action] [options]' \
    '  (defaults: target=all, action=analyze)' \
    '' \
    'Targets (default action: analyze)' \
    '  extensions     Inspect/clean extension folders (keep newest version)' \
    '  caches         Inspect/clean VS Code caches (CachedData, CachedExtensionVSIXs, logs)' \
    '  hosts          Inspect/clean VS Code server builds (keep newest by mtime)' \
    '  all            Run on extensions + caches + hosts' \
    '' \
    'Actions' \
    '  analyze        Report disk usage' \
    '  clean          Delete planned targets (requires --execute)' \
    '' \
    'Extension options' \
    '  -p, --prune-uninstalled         Remove extension dirs not in "code --list-extensions"' \
    '  -E, --extensions-path DIR       Add an extensions directory to scan' \
    '' \
    'Cache options' \
    '  -w, --include-workspace-storage Include User/workspaceStorage' \
    '  -g, --include-global-storage    Include User/globalStorage (settings/data)' \
    '  -C, --config-path DIR           Add a config directory to scan (CachedData,...)' \
    '' \
    'Host options' \
    '  -H, --host-path DIR             Add a server build directory to scan (e.g., ~/.vscode-server/bin)' \
    '' \
    'Global options' \
    '  -x, --execute                   Execute deletions (otherwise dry-run)' \
    '  -v, --verbose                   Show missing paths in detail' \
    '  -q, --quiet                     Suppress banner output' \
    '  -h, --help                      Show this help' \
    '' \
    'Examples' \
    '  vscode-broom' \
    '  vscode-broom clean' \
    '  vscode-broom clean --execute' \
    '  vscode-broom hosts clean --execute' \
    '  vscode-broom extensions clean --prune-uninstalled --execute' \
    '  vscode-broom caches clean --execute'
}

command_exists() {
  command -v "$1" > /dev/null 2>&1
}

require_cmd() {
  local cmd=$1
  if ! command_exists "$cmd"; then
    err "Missing required command: $cmd"
  fi
}

require_runtime_deps() {
  local cmd
  for cmd in find du sort awk tail rm; do
    require_cmd "$cmd"
  done
}

cache_paths_for_cfg() {
  local cfg=$1
  [[ -d "$cfg" ]] || return 0

  local -a paths=(
    "$cfg/CachedData"
    "$cfg/CachedExtensionVSIXs"
    "$cfg/logs"
  )

  if "$INCLUDE_WS_STORAGE"; then
    paths+=("$cfg/User/workspaceStorage")
  fi

  if "$INCLUDE_GLOBAL_STORAGE"; then
    paths+=("$cfg/User/globalStorage")
  fi

  printf '%s\n' "${paths[@]}"
}

measure_path() {
  local path=$1
  local display
  display=$(human_path "$path")
  if [[ -e "$path" ]]; then
    local bytes
    bytes=$(dir_size_bytes "$path")
    printf '  %-8s %s\n' "$(format_bytes "$bytes")" "$display"
  else
    printf '  %-8s %s\n' "(missing)" "$display"
  fi
}

declare -a PLAN_REMOVALS=()
declare -A PLAN_SEEN=()

add_removal() {
  local path=$1
  if [[ -e "$path" && -z ${PLAN_SEEN[$path]:-} ]]; then
    PLAN_SEEN[$path]=1
    PLAN_REMOVALS+=("$path")
  fi
}

declare -A INSTALLED_EXT=()
declare -A PRUNE_SCOPE_LOADED=()
declare -A PRUNE_SCOPE_SKIPPED=()
declare -A PRUNE_SCOPE_REASON=()
declare -A PRUNE_SCOPE_CLI=()

prune_scope_for_dir() {
  local dir=$1
  case "$dir" in
    "$HOME/.vscode-server-insiders"/* | "$HOME/.vscode-server-insiders")
      printf 'server:%s' "$HOME/.vscode-server-insiders"
      ;;
    "$HOME/.vscode-server"/* | "$HOME/.vscode-server")
      printf 'server:%s' "$HOME/.vscode-server"
      ;;
    "$HOME/.vscode-insiders"/* | "$HOME/.vscode-insiders")
      printf 'desktop:%s' "$HOME/.vscode-insiders"
      ;;
    "$HOME/.vscode-oss"/* | "$HOME/.vscode-oss")
      printf 'desktop:%s' "$HOME/.vscode-oss"
      ;;
    "$HOME/.vscode"/* | "$HOME/.vscode")
      printf 'desktop:%s' "$HOME/.vscode"
      ;;
    *)
      printf 'custom:%s' "$dir"
      ;;
  esac
}

prune_scope_label() {
  local scope=$1
  local kind=${scope%%:*}
  local root=${scope#*:}
  case "$kind" in
    server | desktop)
      printf '%s (%s)' "$(variant_label "$root")" "$(human_path "$root")"
      ;;
    custom)
      printf 'Custom (%s)' "$(human_path "$root")"
      ;;
  esac
}

find_server_cli_in_base() {
  local base=$1
  [[ -d "$base" ]] || return 1

  local line name candidate
  while IFS= read -r line; do
    name=${line#* }
    for candidate in \
      "$base/$name/bin/code" \
      "$base/$name/server/bin/code" \
      "$base/$name/bin/remote-cli/code"; do
      [[ -x "$candidate" ]] && {
        printf '%s' "$candidate"
        return 0
      }
    done
  done < <(find "$base" -maxdepth 1 -mindepth 1 -type d -printf '%T@ %f\n' | sort -nr)

  return 1
}

server_code_cli_for_root() {
  local root=$1
  local candidate

  candidate=$(find_server_cli_in_base "$root/cli/servers" || true)
  [[ -n "$candidate" ]] && {
    printf '%s' "$candidate"
    return 0
  }

  candidate=$(find_server_cli_in_base "$root/bin" || true)
  [[ -n "$candidate" ]] && {
    printf '%s' "$candidate"
    return 0
  }

  return 1
}

mark_prune_skip() {
  local scope=$1 reason=$2
  if [[ -z ${PRUNE_SCOPE_SKIPPED[$scope]:-} ]]; then
    PRUNE_SCOPE_SKIPPED[$scope]=1
    PRUNE_SCOPE_REASON[$scope]=$reason
  fi
}

ensure_prune_scope_loaded() {
  local scope=$1
  [[ -n ${PRUNE_SCOPE_LOADED[$scope]:-} ]] && return 0
  [[ -n ${PRUNE_SCOPE_SKIPPED[$scope]:-} ]] && return 1

  local kind=${scope%%:*}
  local root=${scope#*:}
  local code_cli=""

  if [[ "$kind" == "server" ]]; then
    if ! code_cli=$(server_code_cli_for_root "$root"); then
      mark_prune_skip "$scope" "server CLI not found under $(human_path "$root")"
      return 1
    fi

    local output
    if ! output=$("$code_cli" --list-extensions); then
      mark_prune_skip "$scope" "server CLI failed: $(human_path "$code_cli")"
      return 1
    fi

    PRUNE_SCOPE_CLI[$scope]=$(human_path "$code_cli")
    local line
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      INSTALLED_EXT["$scope|$line"]=1
    done < <(printf '%s\n' "$output")

    PRUNE_SCOPE_LOADED[$scope]=1
    return 0
  fi

  local -a candidates=()
  mapfile -t candidates < <(desktop_cli_candidates_for_root "$root")
  local -a available=()
  local candidate
  for candidate in "${candidates[@]}"; do
    if command_exists "$candidate"; then
      available+=("$candidate")
    fi
  done

  if ((${#available[@]} == 0)); then
    local label
    label=$(join_by '/' "${candidates[@]}")
    if desktop_cli_required_for_root "$root"; then
      err "$label not found; --prune-uninstalled requires the VS Code CLI ('$label')"
    fi
    mark_prune_skip "$scope" "desktop CLI not found: $label"
    return 1
  fi

  local -a outputs=()
  local cli output
  for cli in "${available[@]}"; do
    if ! output=$("$cli" --list-extensions); then
      if desktop_cli_required_for_root "$root"; then
        err "$cli failed; --prune-uninstalled requires '$cli --list-extensions' to succeed"
      fi
      mark_prune_skip "$scope" "desktop CLI failed: $cli"
      return 1
    fi
    outputs+=("$output")
  done

  PRUNE_SCOPE_CLI[$scope]=$(join_by ', ' "${available[@]}")
  for output in "${outputs[@]}"; do
    local line
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      INSTALLED_EXT["$scope|$line"]=1
    done < <(printf '%s\n' "$output")
  done

  PRUNE_SCOPE_LOADED[$scope]=1
  return 0
}

prepare_prune_scopes() {
  if ! "$PRUNE_UNINSTALLED"; then
    return
  fi

  local dir scope
  for dir in "${EXT_DIRS[@]}"; do
    scope=$(prune_scope_for_dir "$dir")
    ensure_prune_scope_loaded "$scope" || true
  done
}

report_prune_skips() {
  if ! "$PRUNE_UNINSTALLED"; then
    return
  fi

  local count=${#PRUNE_SCOPE_SKIPPED[@]}
  if ((count == 0)); then
    return
  fi

  local noun="scope"
  ((count > 1)) && noun="scopes"
  log "Prune-uninstalled skipped for $count $noun (use -v for details)."

  if "$VERBOSE"; then
    local scope
    for scope in "${!PRUNE_SCOPE_SKIPPED[@]}"; do
      log "  - $(prune_scope_label "$scope"): ${PRUNE_SCOPE_REASON[$scope]}"
    done
  fi
}

report_prune_cli_usage() {
  if ! "$PRUNE_UNINSTALLED" || ! "$VERBOSE"; then
    return
  fi

  if ((${#PRUNE_SCOPE_CLI[@]} == 0)); then
    return
  fi

  if "$PRINT_GAP"; then
    echo
  fi

  log "Prune-uninstalled CLI:"
  local scope
  for scope in "${!PRUNE_SCOPE_CLI[@]}"; do
    log "  - $(prune_scope_label "$scope"): ${PRUNE_SCOPE_CLI[$scope]}"
  done
  PRINT_GAP=true
}

ver_gt() {
  local a=$1 b=$2
  [[ "$(printf '%s\n%s\n' "$a" "$b" | sort -V | tail -n1)" == "$a" && "$a" != "$b" ]]
}

parse_extension_entry() {
  local entry=$1
  local version=${entry##*-}
  if [[ "$version" == "$entry" ]]; then
    printf '%s\t\n' "$entry"
    return
  fi

  if [[ $version =~ ^[0-9][0-9A-Za-z.+-]*$ ]]; then
    local base=${entry%-"${version}"}
    printf '%s\t%s\n' "$base" "$version"
  else
    printf '%s\t\n' "$entry"
  fi
}

plan_extension_dir() {
  local dir=$1
  [[ -d "$dir" ]] || return 0
  TARGET_PATH_FOUND=true

  local prune_ok=false
  local scope=""
  if "$PRUNE_UNINSTALLED"; then
    scope=$(prune_scope_for_dir "$dir")
    if ensure_prune_scope_loaded "$scope"; then
      prune_ok=true
    fi
  fi

  declare -A latest_version=()

  local entry base version current_latest
  while IFS= read -r entry; do
    read -r base version < <(parse_extension_entry "$entry")
    [[ -n "$version" ]] || continue

    current_latest=${latest_version[$base]:-}
    if [[ -z "$current_latest" ]] || ver_gt "$version" "$current_latest"; then
      latest_version[$base]=$version
    fi
  done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d -printf '%f\n')

  while IFS= read -r entry; do
    read -r base version < <(parse_extension_entry "$entry")
    [[ -n "$version" ]] || continue

    if "$PRUNE_UNINSTALLED" && "$prune_ok" && [[ -z ${INSTALLED_EXT["$scope|$base"]:-} ]]; then
      add_removal "$dir/$entry"
      continue
    fi

    if [[ "$version" != "${latest_version[$base]}" ]]; then
      add_removal "$dir/$entry"
    fi
  done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d -printf '%f\n')
}

plan_config_dir() {
  local cfg=$1
  [[ -d "$cfg" ]] || return 0
  TARGET_PATH_FOUND=true

  local path
  while IFS= read -r path; do
    add_removal "$path"
  done < <(cache_paths_for_cfg "$cfg")
}

is_server_root_dir() {
  local path="${1%/}"
  case "$path" in
    "$HOME/.vscode-server" | "$HOME/.vscode-server-insiders")
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

host_entry_lines() {
  local dir=$1
  [[ -d "$dir" ]] || return 0

  local line name
  if is_server_root_dir "$dir"; then
    while IFS= read -r line; do
      name=${line#* }
      case "$name" in
        code-*)
          printf '%s\n' "$line"
          ;;
      esac
    done < <(find "$dir" -maxdepth 1 -mindepth 1 \( -type d -o -type f \) -printf '%T@ %f\n')
    return 0
  fi

  while IFS= read -r line; do
    name=${line#* }
    case "$name" in
      data | extensions | User | user-data | logs | tmp | workspaceStorage | globalStorage | cli | servers | bin)
        continue
        ;;
    esac
    printf '%s\n' "$line"
  done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d -printf '%T@ %f\n')
}

newest_host_entry_name() {
  local dir=$1
  host_entry_lines "$dir" |
    LC_ALL=C sort -k1,1nr -k2 |
    head -n1 |
    awk '{ sub(/^[^ ]+ /, ""); print }'
}

host_dir_has_entries() {
  local dir=$1
  [[ -d "$dir" ]] || return 1
  while IFS= read -r _; do
    return 0
  done < <(host_entry_lines "$dir")
  return 1
}

host_dir_used_bytes() {
  local dir=$1
  [[ -d "$dir" ]] || {
    printf '0'
    return 0
  }

  local total=0
  local line name
  while IFS= read -r line; do
    name=${line#* }
    total=$((total + $(dir_size_bytes "$dir/$name")))
  done < <(host_entry_lines "$dir")

  printf '%s' "$total"
}

plan_host_dir() {
  local dir=$1
  [[ -d "$dir" ]] || return 0
  TARGET_PATH_FOUND=true

  # Keep the newest (by mtime) install, remove older ones
  local newest_name=""
  newest_name=$(newest_host_entry_name "$dir")

  [[ -n "$newest_name" ]] || return 0

  local line name
  while IFS= read -r line; do
    name=${line#* }
    [[ "$name" == "$newest_name" ]] && continue
    add_removal "$dir/$name"
  done < <(host_entry_lines "$dir")
}

count_stale_extensions_dir() {
  local dir=$1
  [[ -d "$dir" ]] || {
    printf '0'
    return 0
  }

  local prune_ok=false
  local scope=""
  if "$PRUNE_UNINSTALLED"; then
    scope=$(prune_scope_for_dir "$dir")
    if [[ -n ${PRUNE_SCOPE_LOADED[$scope]:-} ]]; then
      prune_ok=true
    fi
  fi

  declare -A latest_version=()

  local entry base version current_latest
  while IFS= read -r entry; do
    read -r base version < <(parse_extension_entry "$entry")
    [[ -n "$version" ]] || continue

    current_latest=${latest_version[$base]:-}
    if [[ -z "$current_latest" ]] || ver_gt "$version" "$current_latest"; then
      latest_version[$base]=$version
    fi
  done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d -printf '%f\n')

  local count=0
  while IFS= read -r entry; do
    read -r base version < <(parse_extension_entry "$entry")
    [[ -n "$version" ]] || continue

    if "$PRUNE_UNINSTALLED" && "$prune_ok" && [[ -z ${INSTALLED_EXT["$scope|$base"]:-} ]]; then
      ((count += 1)) || true
      continue
    fi

    if [[ "$version" != "${latest_version[$base]}" ]]; then
      ((count += 1)) || true
    fi
  done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d -printf '%f\n')

  printf '%s' "$count"
}

stale_extensions_bytes() {
  local dir=$1
  [[ -d "$dir" ]] || {
    printf '0'
    return 0
  }

  local prune_ok=false
  local scope=""
  if "$PRUNE_UNINSTALLED"; then
    scope=$(prune_scope_for_dir "$dir")
    if [[ -n ${PRUNE_SCOPE_LOADED[$scope]:-} ]]; then
      prune_ok=true
    fi
  fi

  declare -A latest_version=()

  local entry base version current_latest
  while IFS= read -r entry; do
    read -r base version < <(parse_extension_entry "$entry")
    [[ -n "$version" ]] || continue
    current_latest=${latest_version[$base]:-}
    if [[ -z "$current_latest" ]] || ver_gt "$version" "$current_latest"; then
      latest_version[$base]=$version
    fi
  done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d -printf '%f\n')

  local total=0
  while IFS= read -r entry; do
    read -r base version < <(parse_extension_entry "$entry")
    [[ -n "$version" ]] || continue

    if "$PRUNE_UNINSTALLED" && "$prune_ok" && [[ -z ${INSTALLED_EXT["$scope|$base"]:-} ]]; then
      total=$((total + $(dir_size_bytes "$dir/$entry")))
      continue
    fi

    if [[ "$version" != "${latest_version[$base]}" ]]; then
      total=$((total + $(dir_size_bytes "$dir/$entry")))
    fi
  done < <(find "$dir" -maxdepth 1 -mindepth 1 -type d -printf '%f\n')

  printf '%s' "$total"
}

count_stale_hosts_dir() {
  local dir=$1
  [[ -d "$dir" ]] || {
    printf '0'
    return 0
  }

  local total=0
  local line
  while IFS= read -r line; do
    ((++total))
  done < <(host_entry_lines "$dir")

  if ((total <= 1)); then
    printf '0'
  else
    printf '%s' "$((total - 1))"
  fi
}

stale_hosts_bytes() {
  local dir=$1
  [[ -d "$dir" ]] || {
    printf '0'
    return 0
  }

  local newest_name=""
  newest_name=$(newest_host_entry_name "$dir")
  [[ -n "$newest_name" ]] || {
    printf '0'
    return 0
  }

  local total=0
  local line name
  while IFS= read -r line; do
    name=${line#* }
    [[ "$name" == "$newest_name" ]] && continue
    total=$((total + $(dir_size_bytes "$dir/$name")))
  done < <(host_entry_lines "$dir")

  printf '%s' "$total"
}

compute_stale_totals() {
  STALE_EXT_COUNT=0
  STALE_EXT_BYTES=0
  STALE_HOST_COUNT=0
  STALE_HOST_BYTES=0
  EXT_USED_BYTES=0
  HOST_USED_BYTES=0
  CACHE_USED_BYTES=0
  CACHE_RECLAIM_BYTES=0
  EXT_EXISTING_COUNT=0
  CACHE_EXISTING_COUNT=0
  HOST_EXISTING_COUNT=0

  local dir
  for dir in "${EXT_DIRS[@]}"; do
    if [[ -d "$dir" ]]; then
      ((++EXT_EXISTING_COUNT))
      EXT_USED_BYTES=$((EXT_USED_BYTES + $(dir_size_bytes "$dir")))
    fi
    local c sb
    c=$(count_stale_extensions_dir "$dir") || c=0
    sb=$(stale_extensions_bytes "$dir") || sb=0
    c=${c:-0}
    sb=${sb:-0}
    ((STALE_EXT_COUNT += c)) || true
    ((STALE_EXT_BYTES += sb)) || true
  done

  local host_dir
  for host_dir in "${HOST_DIRS[@]}"; do
    if [[ -d "$host_dir" ]] && host_dir_has_entries "$host_dir"; then
      ((++HOST_EXISTING_COUNT))
      local host_bytes
      host_bytes=$(host_dir_used_bytes "$host_dir")
      HOST_USED_BYTES=$((HOST_USED_BYTES + host_bytes))
    fi
    local c sb
    c=$(count_stale_hosts_dir "$host_dir") || c=0
    sb=$(stale_hosts_bytes "$host_dir") || sb=0
    c=${c:-0}
    sb=${sb:-0}
    ((STALE_HOST_COUNT += c)) || true
    ((STALE_HOST_BYTES += sb)) || true
  done

  local cfg
  for cfg in "${CONFIG_DIRS[@]}"; do
    local path
    while IFS= read -r path; do
      if [[ -d "$path" ]]; then
        ((++CACHE_EXISTING_COUNT))
        local bytes
        bytes=$(dir_size_bytes "$path")
        CACHE_USED_BYTES=$((CACHE_USED_BYTES + bytes))
        CACHE_RECLAIM_BYTES=$((CACHE_RECLAIM_BYTES + bytes))
      fi
    done < <(cache_paths_for_cfg "$cfg")
  done
}

print_detected() {
  # de-duplicate variants
  declare -A seen=()
  local unique_variants=()
  local v
  for v in "${DETECTED_VARIANTS[@]}"; do
    [[ -z "$v" ]] && continue
    if [[ -z ${seen[$v]:-} ]]; then
      unique_variants+=("$v")
      seen[$v]=1
    fi
  done

  if ((${#unique_variants[@]} > 0)); then
    log "Detected:"
    local v
    for v in "${unique_variants[@]}"; do
      printf '  - %s\n' "$v"
    done
  else
    log "Detected: none"
  fi
}

analyze_extensions() {
  local -a existing=()
  local -a missing=()
  local dir
  for dir in "${EXT_DIRS[@]}"; do
    if [[ -d "$dir" ]]; then
      existing+=("$dir")
    else
      missing+=("$dir")
    fi
  done

  if ((${#existing[@]} == 0)); then
    if "$VERBOSE" || [[ $TARGET == "extensions" ]]; then
      if "$PRINT_GAP"; then
        echo
      fi
      log "Extension: none found under known roots."
      PRINT_GAP=true
      if "$VERBOSE"; then
        local display_missing=()
        local m
        for m in "${missing[@]}"; do
          display_missing+=("$(human_path "$m")")
        done
        print_missing "extension paths" "${display_missing[@]}"
      fi
    fi
    return
  fi

  if "$PRINT_GAP"; then
    echo
  fi
  log "Extension"
  PRINT_GAP=true
  local path
  local total_bytes=0
  for path in "${existing[@]}"; do
    local bytes
    bytes=$(dir_size_bytes "$path")
    printf '  %-8s %s\n' "$(format_bytes "$bytes")" "$(human_path "$path")"
    total_bytes=$((total_bytes + bytes))
  done

  local stale_total=0
  local stale_bytes=0
  for dir in "${EXT_DIRS[@]}"; do
    local c
    if ! c=$(count_stale_extensions_dir "$dir"); then
      c=0
    fi
    c=${c:-0}
    ((stale_total += c)) || true
    local sb
    if ! sb=$(stale_extensions_bytes "$dir"); then
      sb=0
    fi
    sb=${sb:-0}
    ((stale_bytes += sb)) || true
  done
  STALE_EXT_COUNT=$stale_total
  STALE_EXT_BYTES=$stale_bytes
  if ((stale_total > 0)); then
    log "Stale extension versions: $stale_total ($(format_bytes "$stale_bytes"))"
  else
    log "Stale extension versions: none (already keeping newest per extension)"
  fi
  report_prune_skips
  report_prune_cli_usage

  if ((${#missing[@]})); then
    local display_missing=()
    local m
    for m in "${missing[@]}"; do
      display_missing+=("$(human_path "$m")")
    done
    print_missing "extension paths (ignored)" "${display_missing[@]}"
  fi
}

analyze_caches() {
  local -a existing=()
  local -a missing=()
  local cfg
  for cfg in "${CONFIG_DIRS[@]}"; do
    local path
    while IFS= read -r path; do
      if [[ -d "$path" ]]; then
        existing+=("$path")
      else
        missing+=("$path")
      fi
    done < <(cache_paths_for_cfg "$cfg")
  done

  if ((${#existing[@]} == 0)); then
    if "$VERBOSE" || [[ $TARGET == "caches" ]]; then
      if "$PRINT_GAP"; then
        echo
      fi
      log "Cache & Log: none found under known roots."
      PRINT_GAP=true
      if "$VERBOSE"; then
        local display_missing=()
        local m
        for m in "${missing[@]}"; do
          display_missing+=("$(human_path "$m")")
        done
        print_missing "cache paths" "${display_missing[@]}"
      fi
    fi
    return
  fi

  if "$PRINT_GAP"; then
    echo
  fi
  log "Cache & Log"
  PRINT_GAP=true
  local path
  for path in "${existing[@]}"; do
    measure_path "$path"
  done

  if ((${#missing[@]})); then
    local display_missing=()
    local m
    for m in "${missing[@]}"; do
      display_missing+=("$(human_path "$m")")
    done
    print_missing "cache paths (ignored)" "${display_missing[@]}"
  fi
}

analyze_hosts() {
  local -a existing=()
  local dir
  for dir in "${HOST_DIRS[@]}"; do
    if [[ -d "$dir" ]] && host_dir_has_entries "$dir"; then
      existing+=("$dir")
    fi
  done

  if ((${#existing[@]} == 0)); then
    if "$VERBOSE" || [[ $TARGET == "hosts" ]]; then
      if "$PRINT_GAP"; then
        echo
      fi
      log "Server build: none found under known roots."
      PRINT_GAP=true
    fi
    return
  fi

  if "$PRINT_GAP"; then
    echo
  fi
  log "Server build"
  PRINT_GAP=true
  local path
  for path in "${existing[@]}"; do
    local bytes
    bytes=$(host_dir_used_bytes "$path")
    printf '  %-8s %s\n' "$(format_bytes "$bytes")" "$(human_path "$path")"
  done

  local stale_total=0
  local stale_bytes=0
  local host_dir
  for host_dir in "${HOST_DIRS[@]}"; do
    local c
    if ! c=$(count_stale_hosts_dir "$host_dir"); then
      c=0
    fi
    c=${c:-0}
    ((stale_total += c)) || true
    local sb
    if ! sb=$(stale_hosts_bytes "$host_dir"); then
      sb=0
    fi
    sb=${sb:-0}
    ((stale_bytes += sb)) || true
  done
  STALE_HOST_COUNT=$stale_total
  STALE_HOST_BYTES=$stale_bytes
  if ((stale_total > 0)); then
    log "Old server builds: $stale_total ($(format_bytes "$stale_bytes"))"
  fi
}

print_summary() {
  if [[ $ACTION != "analyze" ]]; then
    return
  fi
  if "$PRINT_GAP"; then
    echo
  fi
  log "Summary:"
  local reclaim_bytes=0
  local summary_has_data=false
  case "$TARGET" in
    hosts)
      if ((HOST_EXISTING_COUNT > 0 || STALE_HOST_BYTES > 0)); then
        local host_used
        local host_rec
        host_used=$(format_bytes "$HOST_USED_BYTES")
        host_rec=$(format_bytes "$STALE_HOST_BYTES")
        log "  Server build: total $host_used; old builds $host_rec"
        summary_has_data=true
        reclaim_bytes=$STALE_HOST_BYTES
      else
        log "  No server build data found under known roots."
      fi
      ;;
    extensions)
      if ((EXT_EXISTING_COUNT > 0 || STALE_EXT_BYTES > 0)); then
        local ext_used
        local ext_rec
        ext_used=$(format_bytes "$EXT_USED_BYTES")
        ext_rec=$(format_bytes "$STALE_EXT_BYTES")
        log "  Extension: total $ext_used; stale reclaimable $ext_rec"
        summary_has_data=true
        reclaim_bytes=$STALE_EXT_BYTES
      else
        log "  No extension data found under known roots."
      fi
      ;;
    caches)
      if ((CACHE_EXISTING_COUNT > 0)); then
        local cache_used
        cache_used=$(format_bytes "$CACHE_USED_BYTES")
        log "  Cache & Log: total $cache_used (all removable on clean)"
        summary_has_data=true
        reclaim_bytes=$CACHE_RECLAIM_BYTES
      else
        log "  No cache/log data found under known roots."
      fi
      ;;
    all)
      local any=false
      if ((HOST_EXISTING_COUNT > 0 || STALE_HOST_BYTES > 0)); then
        local host_used
        local host_rec
        host_used=$(format_bytes "$HOST_USED_BYTES")
        host_rec=$(format_bytes "$STALE_HOST_BYTES")
        log "  Server build: total $host_used; old builds $host_rec"
        any=true
      fi
      if ((EXT_EXISTING_COUNT > 0 || STALE_EXT_BYTES > 0)); then
        local ext_used
        local ext_rec
        ext_used=$(format_bytes "$EXT_USED_BYTES")
        ext_rec=$(format_bytes "$STALE_EXT_BYTES")
        log "  Extension: total $ext_used; stale reclaimable $ext_rec"
        any=true
      fi
      if ((CACHE_EXISTING_COUNT > 0)); then
        local cache_used
        cache_used=$(format_bytes "$CACHE_USED_BYTES")
        log "  Cache & Log: total $cache_used (all removable on clean)"
        any=true
      fi
      if ! "$any"; then
        log "  No VS Code data found under known roots."
      else
        reclaim_bytes=$((STALE_HOST_BYTES + STALE_EXT_BYTES + CACHE_RECLAIM_BYTES))
      fi
      summary_has_data=$any
      ;;
  esac
  if "$summary_has_data"; then
    log "  Reclaimable (est.): $(format_bytes "$reclaim_bytes")"
  fi
}

analyze_paths() {
  prepare_prune_scopes
  compute_stale_totals
  print_detected
  PRINT_GAP=true
  case "$TARGET" in
    extensions)
      analyze_extensions
      ;;
    caches)
      analyze_caches
      ;;
    hosts)
      analyze_hosts
      ;;
    all)
      analyze_hosts
      analyze_extensions
      analyze_caches
      ;;
    *)
      err "Unknown target: $TARGET"
      ;;
  esac
  print_summary
}

build_clean_plan() {
  PLAN_REMOVALS=()
  PLAN_SEEN=()
  TARGET_PATH_FOUND=false

  case "$TARGET" in
    extensions)
      local dir
      for dir in "${EXT_DIRS[@]}"; do
        plan_extension_dir "$dir"
      done
      ;;
    caches)
      local cfg
      for cfg in "${CONFIG_DIRS[@]}"; do
        plan_config_dir "$cfg"
      done
      ;;
    hosts)
      local host
      for host in "${HOST_DIRS[@]}"; do
        plan_host_dir "$host"
      done
      ;;
    all)
      local dir cfg host
      for dir in "${EXT_DIRS[@]}"; do
        plan_extension_dir "$dir"
      done
      for cfg in "${CONFIG_DIRS[@]}"; do
        plan_config_dir "$cfg"
      done
      for host in "${HOST_DIRS[@]}"; do
        plan_host_dir "$host"
      done
      ;;
    *)
      err "Unknown target: $TARGET"
      ;;
  esac
}

perform_clean() {
  build_clean_plan
  report_prune_skips
  report_prune_cli_usage

  if [[ ${#PLAN_REMOVALS[@]} -eq 0 ]]; then
    if ! "$TARGET_PATH_FOUND"; then
      case "$TARGET" in
        extensions)
          log "No extension directories found; nothing to clean"
          ;;
        caches)
          log "No cache directories found; nothing to clean"
          ;;
        *)
          log "Nothing to clean"
          ;;
      esac
    else
      log "Nothing to clean"
    fi
    return
  fi

  validate_removal_paths

  log "Targets:"
  local total_bytes=0
  local path bytes
  for path in "${PLAN_REMOVALS[@]}"; do
    bytes=$(dir_size_bytes "$path")
    bytes=${bytes:-0}
    total_bytes=$((total_bytes + bytes))
    printf '  %-8s %s\n' "$(format_bytes "$bytes")" "$(human_path "$path")"
  done

  if ! "$EXECUTE"; then
    log "Dry-run only."
    log "Reclaimable (est.): $(format_bytes "$total_bytes") (${#PLAN_REMOVALS[@]} paths)"
    log "Re-run with --execute to delete."
    return
  fi

  local -a failed=()
  for path in "${PLAN_REMOVALS[@]}"; do
    if ! rm -rf -- "$path"; then
      failed+=("$(human_path "$path")")
    fi
  done

  if ((${#failed[@]})); then
    err "Failed to delete ${#failed[@]} path(s): $(join_by ', ' "${failed[@]}")"
  fi

  log "Deleted ${#PLAN_REMOVALS[@]} paths (reclaimed $(format_bytes "$total_bytes"))"
}

set_target() {
  local new_target=$1
  if "$TARGET_SET" && [[ $TARGET != "$new_target" ]]; then
    err "Conflicting targets: $TARGET already set, cannot set $new_target"
  fi
  TARGET=$new_target
  TARGET_SET=true
}

set_action() {
  local new_action=$1
  if "$ACTION_SET" && [[ $ACTION != "$new_action" ]]; then
    err "Conflicting actions: $ACTION already set, cannot set $new_action"
  fi
  ACTION=$new_action
  ACTION_SET=true
}

parse_args() {
  declare -a POSITIONALS=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      extensions)
        POSITIONALS+=("extensions")
        ;;
      caches)
        POSITIONALS+=("caches")
        ;;
      hosts)
        POSITIONALS+=("hosts")
        ;;
      all)
        POSITIONALS+=("all")
        ;;
      analyze)
        POSITIONALS+=("analyze")
        ;;
      clean)
        POSITIONALS+=("clean")
        ;;
      --execute | -x)
        EXECUTE=true
        ;;
      --prune-uninstalled | -p)
        PRUNE_UNINSTALLED=true
        EXT_FLAG_USED=true
        ;;
      --include-workspace-storage | -w)
        INCLUDE_WS_STORAGE=true
        CACHE_FLAG_USED=true
        ;;
      --include-global-storage | -g)
        INCLUDE_GLOBAL_STORAGE=true
        CACHE_FLAG_USED=true
        ;;
      --extensions-path | -E)
        EXT_FLAG_USED=true
        shift
        [[ $# -gt 0 ]] || err "--extensions-path requires a value"
        validate_user_dir "--extensions-path" "$1"
        EXT_DIRS+=("$1")
        ;;
      --config-path | -C)
        CACHE_FLAG_USED=true
        shift
        [[ $# -gt 0 ]] || err "--config-path requires a value"
        validate_user_dir "--config-path" "$1"
        CONFIG_DIRS+=("$1")
        ;;
      --host-path | -H)
        HOST_FLAG_USED=true
        shift
        [[ $# -gt 0 ]] || err "--host-path requires a value"
        validate_user_dir "--host-path" "$1"
        HOST_DIRS+=("$1")
        ;;
      --verbose | -v)
        VERBOSE=true
        ;;
      --quiet | -q)
        QUIET=true
        ;;
      --help | -h)
        usage
        exit 0
        ;;
      -*)
        err "Unknown flag: $1"
        ;;
      *)
        err "Unexpected argument: $1"
        ;;
    esac
    shift
  done

  if ((${#POSITIONALS[@]} == 0)); then
    TARGET="all"
    ACTION=${ACTION:-analyze}
  else
    case "${POSITIONALS[0]}" in
      extensions | caches | hosts | all)
        set_target "${POSITIONALS[0]}"
        if ((${#POSITIONALS[@]} > 1)); then
          set_action "${POSITIONALS[1]}"
        fi
        ;;
      analyze | clean)
        if ((${#POSITIONALS[@]} > 1)); then
          err "Target must come before action (use: vscode-broom [target] [action])"
        fi
        set_action "${POSITIONALS[0]}"
        TARGET=${TARGET:-all}
        ;;
      *)
        err "Unexpected argument: ${POSITIONALS[0]}"
        ;;
    esac

    if ((${#POSITIONALS[@]} > 2)); then
      err "Too many arguments: ${POSITIONALS[*]}"
    fi
  fi

  case "$TARGET" in
    extensions | caches | hosts | all) ;;
    *)
      err "Unknown target: $TARGET"
      ;;
  esac

  case "$ACTION" in
    analyze | clean) ;;
    *)
      err "Unknown action: $ACTION"
      ;;
  esac

  if [[ $TARGET == "extensions" ]] && "$CACHE_FLAG_USED"; then
    err "Cache flags used while target is extensions"
  fi

  if [[ $TARGET == "caches" ]] && "$EXT_FLAG_USED"; then
    err "Extension flags used while target is caches"
  fi

  if [[ $TARGET == "hosts" ]] && "$EXT_FLAG_USED"; then
    err "Extension flags used while target is hosts"
  fi

  if [[ $TARGET != "hosts" && $TARGET != "all" ]] && "$HOST_FLAG_USED"; then
    err "Host flags used while target is $TARGET"
  fi
}

main() {
  # Pre-scan --quiet so banner is suppressed when usage() is called from parse_args.
  local arg
  for arg in "$@"; do
    case "$arg" in
      --quiet | -q)
        QUIET=true
        ;;
    esac
  done

  parse_args "$@"
  print_banner
  require_runtime_deps

  if [[ ${#EXT_DIRS[@]} -eq 0 ]]; then
    EXT_DIRS=("${DEFAULT_EXT_DIRS[@]}")
  fi

  if [[ ${#CONFIG_DIRS[@]} -eq 0 ]]; then
    CONFIG_DIRS=("${DEFAULT_CONFIG_DIRS[@]}")
  fi

  if [[ ${#HOST_DIRS[@]} -eq 0 ]]; then
    HOST_DIRS=("${DEFAULT_HOST_DIRS[@]}")
  fi
  dedupe_ext_dirs
  dedupe_config_dirs
  dedupe_host_dirs

  case "$ACTION" in
    analyze)
      analyze_paths
      ;;
    clean)
      perform_clean
      ;;
    *)
      err "Unsupported action: $ACTION"
      ;;
  esac
}

main "$@"
